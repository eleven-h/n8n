# n8n 执行日志分析指南

## 🔍 什么是执行日志？

执行日志是 n8n 工作流运行过程中产生的详细记录，包含了每个节点的执行状态、数据流转、错误信息等关键信息，是**调试和排错的重要工具**。

## 📊 日志类型和位置

### 1. 工作流执行日志
- **位置**：n8n 界面 → 工作流 → 执行历史
- **内容**：工作流整体执行状态、节点执行顺序、数据传递
- **用途**：了解工作流执行流程和性能

### 2. 节点执行日志
- **位置**：节点详情 → 执行信息
- **内容**：单个节点的输入输出、执行时间、错误详情
- **用途**：定位具体节点的执行问题

### 3. 系统日志
- **位置**：服务器日志文件、Docker 容器日志
- **内容**：系统级错误、网络问题、资源使用情况
- **用途**：排查系统级问题

## 🚀 如何查看执行日志

### 方法 1：n8n 界面查看
1. **打开工作流**：选择要分析的工作流
2. **查看执行历史**：点击"执行历史"标签
3. **选择执行记录**：点击具体的执行记录
4. **分析执行详情**：查看每个节点的执行状态

### 方法 2：命令行查看
```bash
# 查看 n8n 进程日志
tail -f ~/.n8n/logs/n8n.log

# 查看 Docker 容器日志
docker logs -f n8n

# 查看系统日志
journalctl -u n8n -f
```

### 方法 3：API 接口查看
```bash
# 获取工作流执行历史
curl -X GET "http://localhost:5678/api/v1/workflows/{id}/executions" \
  -H "Authorization: Bearer your-token"
```

## 📋 日志内容解析

### 1. 工作流执行信息
```json
{
  "id": "execution-id",
  "workflowId": "workflow-id",
  "status": "success",
  "startedAt": "2024-01-15T10:00:00Z",
  "finishedAt": "2024-01-15T10:00:30Z",
  "duration": 30000,
  "nodes": [
    {
      "node": "Webhook",
      "status": "success",
      "startTime": "2024-01-15T10:00:01Z",
      "endTime": "2024-01-15T10:00:02Z"
    }
  ]
}
```

### 2. 节点执行详情
```json
{
  "node": "HTTP Request",
  "status": "success",
  "startTime": "2024-01-15T10:00:02Z",
  "endTime": "2024-01-15T10:00:05Z",
  "duration": 3000,
  "input": [
    {
      "json": {
        "url": "https://api.example.com/data",
        "method": "GET"
      }
    }
  ],
  "output": [
    {
      "json": {
        "status": "success",
        "data": [...]
      }
    }
  ]
}
```

### 3. 错误信息结构
```json
{
  "error": {
    "message": "Request failed with status code 404",
    "name": "HTTPError",
    "stack": "Error: Request failed...",
    "cause": {
      "code": "ENOTFOUND",
      "message": "getaddrinfo ENOTFOUND api.example.com"
    }
  }
}
```

## 🔍 常见日志分析场景

### 场景 1：工作流执行失败

#### 日志特征
```
ERROR: Workflow execution failed
Node "HTTP Request" failed with error: Request timeout
```

#### 分析步骤
1. **查看错误节点**：确定哪个节点失败
2. **检查错误类型**：网络错误、认证错误、数据错误等
3. **分析错误原因**：超时、权限不足、数据格式错误等
4. **查看输入数据**：检查传递给失败节点的数据

#### 解决方案
```javascript
// 在 Code 节点中添加错误处理
try {
  const result = await makeHttpRequest($input.first().json);
  return result;
} catch (error) {
  console.error('HTTP request failed:', error);
  
  // 返回默认值或重试
  return {
    error: error.message,
    fallback: true
  };
}
```

### 场景 2：数据格式不匹配

#### 日志特征
```
ERROR: Cannot read property 'title' of undefined
TypeError: $json.title is not a string
```

#### 分析步骤
1. **检查数据结构**：查看节点的输入数据格式
2. **验证字段存在性**：确认所需字段是否存在
3. **检查数据类型**：验证字段类型是否符合预期
4. **查看上游节点**：检查数据来源节点的输出

#### 解决方案
```javascript
// 添加数据验证
const input = $input.first().json;

if (!input || typeof input !== 'object') {
  throw new Error('Input data is invalid');
}

if (!input.title || typeof input.title !== 'string') {
  throw new Error('Title field is missing or invalid');
}

// 安全地访问数据
const title = input.title || 'Untitled';
const content = input.content || '';
```

### 场景 3：API 调用失败

#### 日志特征
```
ERROR: API rate limit exceeded
ERROR: Authentication failed
ERROR: Network timeout
```

#### 分析步骤
1. **检查 API 状态**：确认第三方服务是否正常
2. **验证认证信息**：检查 API 密钥和权限
3. **查看调用频率**：确认是否超过 API 限制
4. **检查网络连接**：验证网络连通性

#### 解决方案
```javascript
// 添加重试机制
const maxRetries = 3;
let retryCount = 0;

async function makeApiCall() {
  try {
    return await callApi();
  } catch (error) {
    if (retryCount < maxRetries && isRetryableError(error)) {
      retryCount++;
      await delay(1000 * retryCount); // 指数退避
      return makeApiCall();
    }
    throw error;
  }
}

function isRetryableError(error) {
  return error.code === 'RATE_LIMIT' || 
         error.code === 'TIMEOUT' ||
         error.code === 'NETWORK_ERROR';
}
```

### 场景 4：性能问题

#### 日志特征
```
WARN: Node execution took 15 seconds
WARN: Memory usage high: 85%
```

#### 分析步骤
1. **识别慢节点**：查看各节点的执行时间
2. **分析数据量**：检查处理的数据量大小
3. **检查资源使用**：监控 CPU、内存、网络使用
4. **查看并发设置**：确认并发配置是否合理

#### 解决方案
```javascript
// 分批处理大数据
const batchSize = 100;
const items = $input.all();
const batches = [];

for (let i = 0; i < items.length; i += batchSize) {
  batches.push(items.slice(i, i + batchSize));
}

// 并行处理批次
const results = await Promise.all(
  batches.map(batch => processBatch(batch))
);

return results.flat();
```

## 🛠️ 日志分析工具和技巧

### 1. 使用 Code 节点记录日志
```javascript
// 记录关键信息
console.log('Processing item:', {
  id: $json.id,
  type: $json.type,
  timestamp: new Date().toISOString()
});

// 记录数据统计
const items = $input.all();
console.log(`Processing ${items.length} items`);

// 记录性能指标
const startTime = Date.now();
// ... 处理逻辑 ...
const duration = Date.now() - startTime;
console.log(`Processing completed in ${duration}ms`);
```

### 2. 结构化日志记录
```javascript
// 创建结构化日志
const logEntry = {
  level: 'info',
  timestamp: new Date().toISOString(),
  node: 'Data Processing',
  action: 'transform_data',
  input: {
    count: $input.all().length,
    sample: $input.first().json
  },
  metadata: {
    workflowId: $workflow.id,
    executionId: $execution.id
  }
};

console.log(JSON.stringify(logEntry));
```

### 3. 条件日志记录
```javascript
// 根据条件记录不同级别的日志
const logLevel = process.env.LOG_LEVEL || 'info';

function log(level, message, data) {
  const levels = { error: 0, warn: 1, info: 2, debug: 3 };
  
  if (levels[level] <= levels[logLevel]) {
    console.log(`[${level.toUpperCase()}] ${message}`, data);
  }
}

// 使用示例
log('info', 'Processing started', { count: $input.all().length });
log('debug', 'Raw data', $input.first().json);
```

## 📊 日志监控和告警

### 1. 关键指标监控
```javascript
// 监控工作流执行状态
const executionStats = {
  totalExecutions: 0,
  successfulExecutions: 0,
  failedExecutions: 0,
  averageDuration: 0
};

// 记录执行统计
function recordExecution(status, duration) {
  executionStats.totalExecutions++;
  if (status === 'success') {
    executionStats.successfulExecutions++;
  } else {
    executionStats.failedExecutions++;
  }
  
  // 更新平均执行时间
  const total = executionStats.averageDuration * (executionStats.totalExecutions - 1);
  executionStats.averageDuration = (total + duration) / executionStats.totalExecutions;
  
  console.log('Execution stats:', executionStats);
}
```

### 2. 错误率监控
```javascript
// 计算错误率
const errorRate = executionStats.failedExecutions / executionStats.totalExecutions;

// 设置告警阈值
if (errorRate > 0.1) { // 错误率超过 10%
  console.warn('High error rate detected:', errorRate);
  
  // 发送告警通知
  await sendAlert({
    level: 'warning',
    message: `High error rate: ${(errorRate * 100).toFixed(1)}%`,
    details: executionStats
  });
}
```

### 3. 性能监控
```javascript
// 监控节点执行时间
const nodePerformance = new Map();

function recordNodePerformance(nodeName, duration) {
  if (!nodePerformance.has(nodeName)) {
    nodePerformance.set(nodeName, []);
  }
  
  const times = nodePerformance.get(nodeName);
  times.push(duration);
  
  // 保持最近 100 次记录
  if (times.length > 100) {
    times.shift();
  }
  
  // 计算平均时间
  const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
  
  // 检查性能问题
  if (avgTime > 5000) { // 平均执行时间超过 5 秒
    console.warn(`Slow node detected: ${nodeName}, avg: ${avgTime.toFixed(0)}ms`);
  }
}
```

## 🔧 日志配置优化

### 1. 环境变量配置
```bash
# 设置日志级别
N8N_LOG_LEVEL=debug

# 设置日志输出
N8N_LOG_OUTPUT=console

# 设置日志文件
N8N_LOG_FILE=/var/log/n8n.log

# 设置日志轮转
N8N_LOG_MAX_SIZE=100m
N8N_LOG_MAX_FILES=5
```

### 2. 自定义日志格式
```javascript
// 在 Code 节点中自定义日志格式
const logPrefix = `[${new Date().toISOString()}] [${$workflow.name}]`;

function customLog(level, message, data) {
  const logMessage = `${logPrefix} [${level.toUpperCase()}] ${message}`;
  
  if (data) {
    console.log(logMessage, data);
  } else {
    console.log(logMessage);
  }
}

// 使用示例
customLog('info', 'Processing started');
customLog('debug', 'Input data', $input.first().json);
```

## 🎯 最佳实践

### 1. 日志记录原则
- **完整性**：记录足够的信息用于调试
- **可读性**：使用清晰的日志格式和语言
- **性能**：避免过度记录影响性能
- **安全性**：不要记录敏感信息

### 2. 调试流程
1. **重现问题**：确保能够重现错误
2. **查看日志**：从工作流执行日志开始
3. **定位节点**：确定问题发生的具体节点
4. **分析数据**：检查节点的输入输出数据
5. **验证修复**：确认修复后问题解决

### 3. 预防措施
- **定期检查**：定期查看执行日志和统计
- **设置告警**：配置关键指标的告警阈值
- **性能优化**：持续监控和优化性能瓶颈
- **文档记录**：记录常见问题和解决方案

## 🎉 总结

执行日志分析是 n8n 工作流调试和优化的核心技能。通过掌握日志分析方法，您可以：

1. **快速定位问题**：准确找到问题发生的节点和原因
2. **优化性能**：识别性能瓶颈并优化
3. **预防故障**：通过监控提前发现潜在问题
4. **提升效率**：减少调试时间，提高开发效率

**下一步**：结合本指南，在实际项目中练习日志分析，逐步提升调试技能。
